---
---

<style>
    @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
</style>

<div id="three-container" style="width: 100%; height: 100vh; overflow: hidden; position: relative;"></div>

<script>
    // Import Three.js modules properly for Astro
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

    console.log('--- ThreeDScene script is running ---');

    const container = document.getElementById('three-container');
    if (!container) {
        console.error('Three container not found!');
        throw new Error('Three container not found');
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    // CAMERA 
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 3; 
    camera.position.y = 4; 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // ORBIT CONTROLS 
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.maxPolarAngle = Math.PI / 2;

    // RAYCASTER
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // CSS2DRenderer 
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    labelRenderer.domElement.style.pointerEvents = 'none';
    container.appendChild(labelRenderer.domElement);

    // HOMEPAGE > SECTION DATA
    const sectionData = [
        { name: 'Home', link: '/', radius: 1, angle: Math.PI * 0, color: 0x2ecc71 }, 
        { name: 'Projects', link: '/projects', radius: 2.5, angle: Math.PI * 0.5, color: 0x2ecc71 }, 
        { name: 'Design', link: '/design', radius: 3, angle: Math.PI * 1, color: 0x2ecc71 }, 
        { name: 'About Me', link: '/about', radius: 4, angle: Math.PI * 1.5, color: 0x2ecc71 }, 
    ];

    // STORE REFERENCES FOR DOTS
    const sectionDots: THREE.Mesh[] = [];
    const DOT_SIZE = 0.1;
    
    // TRAIL VARIABLES
    const MAX_TRAIL_POINTS = 500; 
    const TRAIL_ALPHA_DECAY = 0.95;
    const TRAIL_THICKNESS = 1;

    // GRAVITATION POINT
    const centralGeometry = new THREE.SphereGeometry(0.1, 32, 32);
    const centralMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const centralPoint = new THREE.Mesh(centralGeometry, centralMaterial);
    scene.add(centralPoint);

    // CREATE SECTION DOTS
    sectionData.forEach(data => {
        const geometry = new THREE.SphereGeometry(DOT_SIZE, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: data.color });
        const dot = new THREE.Mesh(geometry, material);

        // Calculate initial position in a circle
        dot.position.x = Math.cos(data.angle) * data.radius;
        dot.position.z = Math.sin(data.angle) * data.radius;
        dot.position.y = 0;

        scene.add(dot);
        sectionDots.push(dot);

        // TRAIL LOGIC
        const trailMaterial = new THREE.LineDashedMaterial({
            color: 0x828282,
            dashSize: 0.1,
            gapSize: 0.2,
            linewidth: 1,
            scale: 1
        });

        const trailGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(MAX_TRAIL_POINTS * 3);
        trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));

        const trailLine = new THREE.Line(trailGeometry, trailMaterial);
        scene.add(trailLine);

        // Store trail data in dot's userData
        dot.userData = {
            name: data.name,
            link: data.link,
            originalAngle: data.angle,
            radius: data.radius,
            trailPoints: [],
            trailLine: trailLine
        };

        // Create and attach text label using CSS class
        const labelDiv = document.createElement('div');
        labelDiv.className = 'three-dot-label'; // Use a specific class name
        labelDiv.textContent = data.name;
        const label = new CSS2DObject(labelDiv);
        label.position.set(0, DOT_SIZE * 2, 0);
        dot.add(label);
    });

    // ANIMATION
    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const orbitSpeedMultiplier = 0.005;
        sectionDots.forEach(dot => {
            // Update individual dot's orbit
            dot.userData.originalAngle += orbitSpeedMultiplier / dot.userData.radius;
            dot.position.x = Math.cos(dot.userData.originalAngle) * dot.userData.radius;
            dot.position.z = Math.sin(dot.userData.originalAngle) * dot.userData.radius;

            // Update Trail Points
            const trailPoints = dot.userData.trailPoints;
            const trailLine = dot.userData.trailLine;

            // Add current position to trail
            trailPoints.push(new THREE.Vector3(dot.position.x, dot.position.y, dot.position.z));

            // Remove oldest point if trail is too long
            while (trailPoints.length > MAX_TRAIL_POINTS) {
                trailPoints.shift();
            }

            // Update positions in the BufferGeometry
            const positionsArray = trailLine.geometry.attributes.position.array;

            // Populate attributes with current trail data
            for (let i = 0; i < trailPoints.length; i++) {
                const point = trailPoints[i];
                positionsArray[i * 3] = point.x;
                positionsArray[i * 3 + 1] = point.y;
                positionsArray[i * 3 + 2] = point.z;
            }

            // Set draw range to only draw the actual points in the trail
            trailLine.geometry.setDrawRange(0, trailPoints.length);

            // Inform Three.js that the position attribute needs updating
            trailLine.geometry.attributes.position.needsUpdate = true;
            
            // Crucial for LineDashedMaterial to work
            trailLine.computeLineDistances(); 
        });

        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
    }

    // WINDOW RESIZING
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize);

    // Click event listener for dot interaction
    function onClick(event: MouseEvent) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(sectionDots);

        if (intersects.length > 0) {
            const clickedDot = intersects[0].object;
            console.log('Clicked dot:', clickedDot.userData.name, 'Navigating to:', clickedDot.userData.link);
            window.location.href = clickedDot.userData.link;
        }
    }
    
    window.addEventListener('click', onClick);

    // Start the animation
    animate();
</script>