---
---
<div id="three-container" style="width: 100%; height: 100vh; overflow: hidden; position: relative;"></div>


<script type="module">

    import * as THREE from '/node_modules/three/build/three.module.js';
    import { OrbitControls } from '/node_modules/three/examples/jsm/controls/OrbitControls.js';

    const container = document.getElementById('three-container');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a); // Your primary background color


    // CAMERA 
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 4; // Adjusted: A good general view for your current dot radii
    camera.position.y = 1; // Adjusted: Slight vertical offset for better perspective

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // INIT ORBIT CONTROLS ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Give a sense of weight
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false; // Prevents panning if you only want rotation
    controls.maxPolarAngle = Math.PI / 2; // Restrict vertical orbit (optional: prevents camera from going below the plane)


    // HOMEPAGE > SECTION DATA ---
    const sectionData = [
        { name: 'Home', link: '/', radius: 1, angle: Math.PI * 0, color: 0x2ecc71 }, // Green
        { name: 'Projects', link: '/projects', radius: 2.5, angle: Math.PI * 0.5, color: 0x2ecc71 }, // Green
        { name: 'Design', link: '/design', radius: 3, angle: Math.PI * 1, color: 0x2ecc71 }, // Green
        { name: 'About Me', link: '/about', radius: 4, angle: Math.PI * 1.5, color: 0x2ecc71 }, // Green
    ];

    // HOMEPAGE > STORE REFERENCES FOR DOTS ---
    const sectionDots = [];
    const DOT_SIZE = 0.1; // SECTION DOTS SIZE
    // --- TRAIL CONSTANTS ---
    const MAX_TRAIL_POINTS = 500; // Updated: VERY long trails
    // TRAIL_ALPHA_DECAY is no longer used with LineDashedMaterial, but kept for reference
    const TRAIL_ALPHA_DECAY = 0.95;
    // TRAIL_THICKNESS is no longer used directly by LineDashedMaterial for thickness
    const TRAIL_THICKNESS = 1;


    // --- NEW: Create a central point (like a subtle sun) ---
    const centralGeometry = new THREE.SphereGeometry(0.1, 32, 32);
    // Corrected: Central dot color from 0x000ff to 0x0000ff (pure blue)
    const centralMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const centralPoint = new THREE.Mesh(centralGeometry, centralMaterial);
    scene.add(centralPoint);


    // --- NEW: Create and position each section dot ---
    sectionData.forEach(data => {
        const geometry = new THREE.SphereGeometry(DOT_SIZE, 32, 32); // Sphere for the dot
        const material = new THREE.MeshBasicMaterial({ color: data.color }); // Dot's color
        const dot = new THREE.Mesh(geometry, material);

        // Calculate initial position in a circle
        dot.position.x = Math.cos(data.angle) * data.radius;
        dot.position.z = Math.sin(data.angle) * data.radius;
        dot.position.y = 0; // Keep them on a flat plane for now

        scene.add(dot);
        sectionDots.push(dot); // Add to our array for animation

        // --- INIT TRAIL LOGIC ---
        // Changed to LineDashedMaterial for dotted lines
        const trailMaterial = new THREE.LineDashedMaterial({
            color: 0x828282, // Back to the dot's color
            dashSize: 0.1,  // Adjust for dot size in dashed line
            gapSize: 0.2,   // Adjust for space between dots
            linewidth: 1,    // Stays at 1 pixel for LineDashedMaterial
            scale: 1       // Required for dashed lines to appear correctly
        });

        const trailGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(MAX_TRAIL_POINTS * 3);
        // Colors attribute is no longer needed as we're not doing per-vertex fading
        // const colors = new Float32Array(MAX_TRAIL_POINTS * 4); 

        trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
        // Removed: trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 4).setUsage(THREE.DynamicDrawUsage));

        const trailLine = new THREE.Line(trailGeometry, trailMaterial);
        scene.add(trailLine);

        // Store trail data in dot's userData
        dot.userData = {
            name: data.name,
            link: data.link,
            originalAngle: data.angle,
            radius: data.radius,
            trailPoints: [],        // Array to hold current positions
            // Removed: trailColors: [], // No longer needed for fading
            trailLine: trailLine    // Reference to the actual Three.js line object
        };
    });

// --- Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const orbitSpeedMultiplier = 0.005; // Adjust this for overall system rotation speed
        sectionDots.forEach(dot => {
            // 1. Update individual dot's orbit
            dot.userData.originalAngle += orbitSpeedMultiplier / dot.userData.radius;
            dot.position.x = Math.cos(dot.userData.originalAngle) * dot.userData.radius;
            dot.position.z = Math.sin(dot.userData.originalAngle) * dot.userData.radius;

            // 2. Update Trail Points
            const trailPoints = dot.userData.trailPoints;
            const trailLine = dot.userData.trailLine;

            // Add current position to trail
            trailPoints.push(new THREE.Vector3(dot.position.x, dot.position.y, dot.position.z));

            // Remove oldest point if trail is too long
            while (trailPoints.length > MAX_TRAIL_POINTS) {
                trailPoints.shift(); // Remove the oldest point
                // Removed: trailColors.splice(0, 4); // No longer needed
            }

            // Update positions in the BufferGeometry
            const positionsArray = trailLine.geometry.attributes.position.array;
            // Removed: const colorsArray = trailLine.geometry.attributes.color.array; // No longer needed

            // Populate attributes with current trail data
            for (let i = 0; i < trailPoints.length; i++) {
                const point = trailPoints[i];
                positionsArray[i * 3] = point.x;
                positionsArray[i * 3 + 1] = point.y;
                positionsArray[i * 3 + 2] = point.z;

                // Fading logic removed as it's not compatible with LineDashedMaterial
                // colorsArray[i * 4] = trailColors[i * 4];
                // colorsArray[i * 4 + 1] = trailColors[i * 4 + 1];
                // colorsArray[i * 4 + 2] = trailColors[i * 4 + 2];
                // colorsArray[i * 4 + 3] = newAlpha;
            }

            // Set draw range to only draw the actual points in the trail
            trailLine.geometry.setDrawRange(0, trailPoints.length);

            // Inform Three.js that the position attribute needs updating
            trailLine.geometry.attributes.position.needsUpdate = true;
            // Removed: trailLine.geometry.attributes.color.needsUpdate = true;
            
            // Crucial for LineDashedMaterial to work
            trailLine.computeLineDistances(); 
        });

        renderer.render(scene, camera);
    }

    // Handle window resizing
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize);

    // Start the animation
    animate();
</script>